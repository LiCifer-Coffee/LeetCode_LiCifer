# 前缀和技巧

## 1. [303] 区域和检索 - 数组不可变

### 题目描述

给定一个整数数组  `nums`，处理以下类型的多个查询:

1. 计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )

### 题目理解

给定一个整数数组 `nums`，处理以下类型的多个查询。

```java
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
```

分别求 `[0, 2]`, `[2, 5]`, `[0, 5]` 对应的和。

### 解题思路

标准的前缀和模板，注意 `for` 循环条件，要使用 `p.length`，不要使用 `nums.length`，还有返回结果是 `p[right + 1] - p[left]`，因为 `p[1] = nums[0]`，`p[2] = nums[0] + nums[1]`。

### 代码实现

```java
class NumArray {
    int[] p;

    public NumArray(int[] nums) {
        p = new int[nums.length + 1];
        for (int i = 1; i < p.length; i++) {
            p[i] = p[i - 1] + nums[i - 1];
        }
    }

    public int sumRange(int left, int right) {
        return p[right + 1] - p[left];
    }
}
```

## 2. [304] 二维区域和检索 - 矩阵不可变

###  题目描述

给定一个二维矩阵 `matrix`，以下类型的多个请求：

- 计算其子矩形范围内元素的总和，该子矩阵的 **左上角** 为 `(row1, col1)` ，**右下角** 为 `(row2, col2)` 。

实现 `NumMatrix` 类：

- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化
- `int sumRegion(int row1, int col1, int row2, int col2)` 返回 **左上角** `(row1, col1)` 、**右下角** `(row2, col2)` 所描述的子矩阵的元素 **总和** 。

### 题目理解

求矩阵任意两点之间的面积，标准的前缀和思想。

![img](https://labuladong.github.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/5.jpeg)

### 解题思路

1. 将矩阵看成一个田字形表格，然后利用 `x-1, y-1` 这些来求中间的面积，`sum = (x2, y2) - (x1-1, y2) - (x2, y1-1) + (x1-1, y1-1)`。
2. 注意理解 `x1-1, y1-1`，其中 `-1` 的意思。

### 代码实现

```java
class NumMatrix {
    int[][] p;
    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        p = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                p[i][j] = p[i - 1][j] + p[i][j - 1] + matrix[i - 1][j - 1] - p[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        return p[row2 + 1][col2 + 1] - p[row1][col2 + 1] - p[row2 + 1][col1] + p[row1][col1];
    }
}
```
## 3. [1314] 矩阵区域和

### 题目描述

给你一个 `m x n` 的矩阵 `mat` 和一个整数 `k`，请你返回一个矩阵 `answer`，其中每个 `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和：

```
i - k <= r <= i + k, j - k <= c <= j + k 且 (r, c) 在矩阵内。
```

### 题目理解

这个题目不好理解，可以理解为，在`answer[i][j]`中以`i,j`为坐标中心，长宽都为k的面积块

### 解题思路


1. 求出前缀和，记住前缀和是要利用前面的和，例如`p[i] = p[i-1]+nums[i-1]`，以这个思路去求前缀和
2. 求矩阵中任意两点的面积，这需要用到前缀和的差值求解，这里用不到原数组`nums[]`
3. 要理解求`(x1,y1)`到`(x2,y2)`之间的面积，实际上是求`(x1,y1)`到`(x2+1,y2+1)`的面积，因为`p[i][j]`中存放的是`p[i-1][j-1]`的值
4. 想想也不难，无非是求前缀和，利用前缀和求区间差值（这里是面积）


### 代码实现

```java
class Solution {

        int[][] p;

        public int[][] matrixBlockSum(int[][] mat, int k) {

            initPreSum(mat);

            int[][] answer = new int[mat.length][mat[0].length];

            for (int i = 0; i < mat.length; i++) {
                for (int j = 0; j < mat[0].length; j++) {
                    int x1 = Math.max((i - k), 0);
                    int y1 = Math.max((j - k), 0);
                    int x2 = Math.min(i + k, mat.length - 1);
                    int y2 = Math.min(j + k, mat[0].length - 1);
                    answer[i][j] = getSum(x1, y1, x2, y2);
                }
            }
            return answer;
        }

        // 初始化前缀和
        private void initPreSum(int[][] mat) {
            p = new int[mat.length + 1][mat[0].length + 1];
            for (int i = 1; i <= mat.length; i++) {
                for (int j = 1; j <= mat[0].length; j++) {
                    p[i][j] = p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1] + mat[i - 1][j - 1];
                }
            }
        }

        // 根据前缀和返回任意两点之间的面积
        private int getSum(int x1, int y1, int x2, int y2) {
            return p[x2 + 1][y2 + 1] - p[x1][y2 + 1] - p[x2 + 1][y1] + p[x1][y1];
        }
    }
```
## 4. [724] 寻找数组的中心下标

### 题目描述

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

### 题目理解

`[1, 7, 3, 6, 5, 6] `，求数组中元素左右两边和相等的索引 ，例如 `1+7+3 = 5+6 `，方法返回`4(6的索引)`


### 解题思路


1. 求出前缀和
2. 前缀和左右相等的那个索引就是答案
3. 第二个`for`循环要按照`nums`来循环，不要按照`p[]`来循环，这样更容易知道数组中的前缀和


### 代码实现

```java
class Solution {
        public int pivotIndex(int[] nums) {

            int[] p = new int[nums.length + 1];
            int index = -1;
            for (int i = 1; i <= nums.length; i++) {
                p[i] = p[i - 1] + nums[i - 1];
            }
            for (int i = 0; i < nums.length; i++) {
                if (p[i] == p[p.length - 1] - p[i] - nums[i]) {
                    index = i;
                    break;
                }
            }
            return index;

        }
    }
```
## 3. [1314] 矩阵区域和

### 题目描述

给你一个 `m x n` 的矩阵 `mat` 和一个整数 `k`，请你返回一个矩阵 `answer`，其中每个 `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和：

```
i - k <= r <= i + k, j - k <= c <= j + k 且 (r, c) 在矩阵内。
```

### 题目理解

这个题目不好理解，可以理解为，在`answer[i][j]`中以`i,j`为坐标中心，长宽都为k的面积块

### 解题思路


1. 求出前缀和，记住前缀和是要利用前面的和，例如`p[i] = p[i-1]+nums[i-1]`，以这个思路去求前缀和
2. 求矩阵中任意两点的面积，这需要用到前缀和的差值求解，这里用不到原数组`nums[]`
3. 要理解求`(x1,y1)`到`(x2,y2)`之间的面积，实际上是求`(x1,y1)`到`(x2+1,y2+1)`的面积，因为`p[i][j]`中存放的是`p[i-1][j-1]`的值
4. 想想也不难，无非是求前缀和，利用前缀和求区间差值（这里是面积）


### 代码实现

```java
class Solution {

        int[][] p;

        public int[][] matrixBlockSum(int[][] mat, int k) {

            initPreSum(mat);

            int[][] answer = new int[mat.length][mat[0].length];

            for (int i = 0; i < mat.length; i++) {
                for (int j = 0; j < mat[0].length; j++) {
                    int x1 = Math.max((i - k), 0);
                    int y1 = Math.max((j - k), 0);
                    int x2 = Math.min(i + k, mat.length - 1);
                    int y2 = Math.min(j + k, mat[0].length - 1);
                    answer[i][j] = getSum(x1, y1, x2, y2);
                }
            }
            return answer;
        }

        // 初始化前缀和
        private void initPreSum(int[][] mat) {
            p = new int[mat.length + 1][mat[0].length + 1];
            for (int i = 1; i <= mat.length; i++) {
                for (int j = 1; j <= mat[0].length; j++) {
                    p[i][j] = p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1] + mat[i - 1][j - 1];
                }
            }
        }

        // 根据前缀和返回任意两点之间的面积
        private int getSum(int x1, int y1, int x2, int y2) {
            return p[x2 + 1][y2 + 1] - p[x1][y2 + 1] - p[x2 + 1][y1] + p[x1][y1];
        }
    }
```
## 3. [1314] 矩阵区域和

### 题目描述

给你一个 `m x n` 的矩阵 `mat` 和一个整数 `k`，请你返回一个矩阵 `answer`，其中每个 `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和：

```
i - k <= r <= i + k, j - k <= c <= j + k 且 (r, c) 在矩阵内。
```

### 题目理解

这个题目不好理解，可以理解为，在`answer[i][j]`中以`i,j`为坐标中心，长宽都为k的面积块

### 解题思路


1. 求出前缀和，记住前缀和是要利用前面的和，例如`p[i] = p[i-1]+nums[i-1]`，以这个思路去求前缀和
2. 求矩阵中任意两点的面积，这需要用到前缀和的差值求解，这里用不到原数组`nums[]`
3. 要理解求`(x1,y1)`到`(x2,y2)`之间的面积，实际上是求`(x1,y1)`到`(x2+1,y2+1)`的面积，因为`p[i][j]`中存放的是`p[i-1][j-1]`的值
4. 想想也不难，无非是求前缀和，利用前缀和求区间差值（这里是面积）


### 代码实现

```java
class Solution {

        int[][] p;

        public int[][] matrixBlockSum(int[][] mat, int k) {

            initPreSum(mat);

            int[][] answer = new int[mat.length][mat[0].length];

            for (int i = 0; i < mat.length; i++) {
                for (int j = 0; j < mat[0].length; j++) {
                    int x1 = Math.max((i - k), 0);
                    int y1 = Math.max((j - k), 0);
                    int x2 = Math.min(i + k, mat.length - 1);
                    int y2 = Math.min(j + k, mat[0].length - 1);
                    answer[i][j] = getSum(x1, y1, x2, y2);
                }
            }
            return answer;
        }

        // 初始化前缀和
        private void initPreSum(int[][] mat) {
            p = new int[mat.length + 1][mat[0].length + 1];
            for (int i = 1; i <= mat.length; i++) {
                for (int j = 1; j <= mat[0].length; j++) {
                    p[i][j] = p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1] + mat[i - 1][j - 1];
                }
            }
        }

        // 根据前缀和返回任意两点之间的面积
        private int getSum(int x1, int y1, int x2, int y2) {
            return p[x2 + 1][y2 + 1] - p[x1][y2 + 1] - p[x2 + 1][y1] + p[x1][y1];
        }
    }
```